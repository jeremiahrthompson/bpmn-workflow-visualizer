/**
 * bpmn-js v8.8.3
 *
 * Placeholder for the actual bpmn-js library
 * In a real implementation, this would be the minified bpmn-js library
 * For this demo, we're using a simplified version that simulates the core functionality
 */

// Basic BpmnJS implementation
class BpmnJS {
  constructor(options) {
    this.options = options || {};
    this.container = options.container && document.querySelector(options.container);
    this.modules = {
      canvas: {
        zoom: function(type) {
          console.log('Zooming to ' + type);
        }
      },
      eventBus: {
        _listeners: {},
        on: function(event, callback) {
          this._listeners[event] = this._listeners[event] || [];
          this._listeners[event].push(callback);
        },
        fire: function(event, data) {
          if (this._listeners[event]) {
            this._listeners[event].forEach(cb => cb(data));
          }
        }
      },
      overlays: {
        _overlays: {},
        add: function(elementId, overlay) {
          this._overlays[elementId] = this._overlays[elementId] || [];
          this._overlays[elementId].push(overlay);
          
          const el = document.querySelector('[data-element-id="' + elementId + '"]');
          if (el && overlay.html) {
            const overlayEl = document.createElement('div');
            overlayEl.className = 'bjs-overlay';
            overlayEl.style.position = 'absolute';
            overlayEl.style.top = (overlay.position.top || 0) + 'px';
            overlayEl.style.right = (overlay.position.right || 0) + 'px';
            overlayEl.innerHTML = overlay.html;
            el.appendChild(overlayEl);
          }
        },
        remove: function(filter) {
          if (filter.element) {
            delete this._overlays[filter.element];
            const el = document.querySelector('[data-element-id="' + filter.element + '"]');
            if (el) {
              const overlays = el.querySelectorAll('.bjs-overlay');
              overlays.forEach(overlay => overlay.remove());
            }
          }
        }
      }
    };
  }

  // Get a specific module
  get(moduleName) {
    return this.modules[moduleName];
  }

  // Import XML
  importXML(xml) {
    return new Promise((resolve, reject) => {
      try {
        if (!this.container) {
          throw new Error('No container specified');
        }
        
        // Parse the XML
        const parser = new DOMParser();
        const doc = parser.parseFromString(xml, 'text/xml');
        
        // Create a simple viewer
        this.container.innerHTML = '';
        this.container.style.position = 'relative';
        
        // Extract process elements
        const elements = doc.querySelectorAll('process > *');
        const plane = doc.querySelector('BPMNPlane');
        
        elements.forEach(element => {
          const id = element.getAttribute('id');
          const name = element.getAttribute('name');
          const type = element.tagName.split(':').pop();
          
          if (id && (type === 'task' || type === 'userTask' || type === 'serviceTask' || 
                     type === 'exclusiveGateway' || type === 'startEvent' || type === 'endEvent')) {
            // Find the shape
            const shape = doc.querySelector(`BPMNShape[bpmnElement="${id}"]`);
            if (shape) {
              const bounds = shape.querySelector('Bounds');
              if (bounds) {
                const x = bounds.getAttribute('x');
                const y = bounds.getAttribute('y');
                const width = bounds.getAttribute('width');
                const height = bounds.getAttribute('height');
                
                // Create element
                const el = document.createElement('div');
                el.setAttribute('data-element-id', id);
                el.className = 'bpmn-element ' + type;
                el.textContent = name;
                el.style.position = 'absolute';
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                el.style.width = width + 'px';
                el.style.height = height + 'px';
                el.style.border = '1px solid #000';
                el.style.display = 'flex';
                el.style.alignItems = 'center';
                el.style.justifyContent = 'center';
                el.style.textAlign = 'center';
                el.style.fontSize = '12px';
                el.style.padding = '5px';
                el.style.boxSizing = 'border-box';
                el.style.overflow = 'hidden';
                
                // Set shape based on type
                if (type === 'startEvent' || type === 'endEvent') {
                  el.style.borderRadius = '50%';
                  el.style.backgroundColor = type === 'startEvent' ? '#cfe7cd' : '#fddbd7';
                } else if (type === 'exclusiveGateway') {
                  el.style.transform = 'rotate(45deg)';
                  el.style.backgroundColor = '#90EE90'; // Green for decision points
                  
                  // Add label outside the rotated shape
                  const label = document.createElement('div');
                  label.textContent = name;
                  label.style.position = 'absolute';
                  label.style.top = '100%';
                  label.style.left = '0';
                  label.style.width = '100%';
                  label.style.textAlign = 'center';
                  label.style.transform = 'rotate(-45deg)';
                  el.appendChild(label);
                  el.style.overflow = 'visible';
                } else if (type === 'userTask') {
                  el.style.backgroundColor = '#FFFF00'; // Bright yellow for Employee Sentiment
                } else if (type === 'serviceTask') {
                  el.style.backgroundColor = '#DDA0DD'; // Purple for Integrations
                } else {
                  el.style.backgroundColor = '#ADD8E6'; // Light blue for Assistant Response
                }
                
                // Add event listener
                el.addEventListener('click', () => {
                  // Extract documentation
                  const elementXml = doc.getElementById(id);
                  let documentation = '';
                  if (elementXml) {
                    const docElement = elementXml.querySelector('documentation');
                    if (docElement) {
                      documentation = docElement.textContent;
                    }
                  }
                  
                  // Fire event bus event
                  this.modules.eventBus.fire('element.click', {
                    element: {
                      id: id,
                      businessObject: {
                        documentation: documentation ? [{ text: documentation }] : []
                      }
                    }
                  });
                });
                
                this.container.appendChild(el);
              }
            }
          }
        });
        
        // Draw sequence flows
        const sequenceFlows = doc.querySelectorAll('sequenceFlow');
        sequenceFlows.forEach(flow => {
          const id = flow.getAttribute('id');
          const sourceRef = flow.getAttribute('sourceRef');
          const targetRef = flow.getAttribute('targetRef');
          const condition = flow.querySelector('conditionExpression');
          
          // Find the edge
          const edge = doc.querySelector(`BPMNEdge[bpmnElement="${id}"]`);
          if (edge) {
            const waypoints = edge.querySelectorAll('waypoint');
            if (waypoints.length >= 2) {
              // Draw line
              const line = document.createElement('div');
              line.className = 'sequence-flow';
              line.setAttribute('data-source', sourceRef);
              line.setAttribute('data-target', targetRef);
              
              // Find the actual shapes to get proper positions
              const sourceShape = doc.querySelector(`BPMNShape[bpmnElement="${sourceRef}"]`);
              const targetShape = doc.querySelector(`BPMNShape[bpmnElement="${targetRef}"]`);
              
              if (sourceShape && targetShape) {
                const sourceBounds = sourceShape.querySelector('Bounds');
                const targetBounds = targetShape.querySelector('Bounds');
                
                if (sourceBounds && targetBounds) {
                  // Calculate center points
                  const sourceX = parseFloat(sourceBounds.getAttribute('x')) + parseFloat(sourceBounds.getAttribute('width')) / 2;
                  const sourceY = parseFloat(sourceBounds.getAttribute('y')) + parseFloat(sourceBounds.getAttribute('height')) / 2;
                  const targetX = parseFloat(targetBounds.getAttribute('x')) + parseFloat(targetBounds.getAttribute('width')) / 2;
                  const targetY = parseFloat(targetBounds.getAttribute('y')) + parseFloat(targetBounds.getAttribute('height')) / 2;
                  
                  // Calculate angle and length
                  const angle = Math.atan2(targetY - sourceY, targetX - sourceX) * 180 / Math.PI;
                  const length = Math.sqrt(Math.pow(targetX - sourceX, 2) + Math.pow(targetY - sourceY, 2));
                  
                  line.style.position = 'absolute';
                  line.style.left = sourceX + 'px';
                  line.style.top = sourceY + 'px';
                  line.style.width = length + 'px';
                  line.style.height = '2px';
                  line.style.backgroundColor = '#333';
                  line.style.transformOrigin = '0 0';
                  line.style.transform = `rotate(${angle}deg)`;
                  
                  // Add arrow
                  const arrow = document.createElement('div');
                  arrow.style.position = 'absolute';
                  arrow.style.right = '0';
                  arrow.style.top = '-4px';
                  arrow.style.width = '0';
                  arrow.style.height = '0';
                  arrow.style.borderTop = '4px solid transparent';
                  arrow.style.borderBottom = '4px solid transparent';
                  arrow.style.borderLeft = '8px solid #333';
                  line.appendChild(arrow);
                  
                  // Add condition label if applicable
                  if (condition) {
                    const label = document.createElement('div');
                    label.textContent = condition.textContent;
                    label.style.position = 'absolute';
                    label.style.fontSize = '10px';
                    label.style.backgroundColor = 'white';
                    label.style.padding = '2px';
                    label.style.top = '2px';
                    label.style.left = '50%';
                    label.style.transform = 'translateX(-50%) rotate(' + (-angle) + 'deg)';
                    label.style.whiteSpace = 'nowrap';
                    line.appendChild(label);
                  }
                  
                  this.container.appendChild(line);
                }
              }
            }
          }
        });
        
        resolve({});
      } catch (err) {
        reject(err);
      }
    });
  }
} 